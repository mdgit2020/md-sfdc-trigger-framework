<html>
   <head>
      <title>Implementing Apex Trigger Framework </title>
   </head>
   <body>
      <!-- ######## This is a comment, visible only in the source editor  ######## -->
      <p data-pm-slice="1 1 []">This article describes the approach for writing the apex trigger framework and how we can leverage it for centralised exception handling. Now a days we can see that most of the projects have some or the other type of trigger refactoring or trigger consolidation work. Project complexity is exponentially increasing due to plethora of features available on the platform. Everything drills down to triggers if you have complex business processes. These kind of situations forces developers and architects to make the proper choice of the framework so that code can be maintained for longer duration.</p>
      <p>This includes:</p>
      <ol class="ak-ol">
         <li>
            <p>Prerequisites</p>
         </li>
         <li>
            <p>Need for trigger framework</p>
         </li>
         <li>
            <p>What capabilities a framework should have?</p>
         </li>
         <li>
            <p>Framework components</p>
         </li>
         <li>
            <p>Adding capabilities to the framework</p>
         </li>
         <li>
            <p>Future enhancements</p>
         </li>
         <li>
            <p>Git</p>
         </li>
      </ol>
      <h1>1. Prerequisites</h1>
      <p>Before you start building the framework you should be familiar with maps, lists and interfaces from the Apex. More important, you should have clear understanding of trigger context, trigger variables and trigger events.</p>
      <h1>2. Need for trigger framework</h1>
      <p>For laying out a strong architectural foundation for implementing complex apex triggers, proper choice of design patterns is required. Trigger framework is used to take out the business logic from triggers and use the consistent pattern for writing the trigger code. Once we introduce framework, we can have centralised and standardised mechanism to orchestrate the triggers running in a single transaction. It can avoid recursion, makes it easy for developers to work on large number of triggers in org. Writing unit test classes becomes easier.</p>
      <p>Most of the time we face 101 SOQL, CPU Time limit exceptions in the existing trigger implementations, to overcome these issues we can best leverage the framework and have the controlled execution of triggers, consolidate them if required.</p>
      <h1>3. What capabilities a framework should have?</h1>
      <p>Let&rsquo;s talk a little bit about the great frameworks available on the internet, Hari Krishnan's framework is one of the most popular implementations among salesforce developers. It&rsquo;s a good starting point for beginners to get familiar with the framework, but its bigger in size. More prescriptive, on what all we should implement, how dispatchers are named.</p>
      <p>Kevin Ohara&rsquo;s framework is minimal and easy to implement, the bypass API is good, if you are aware of what all to bypass.</p>
      <p>Let us list down the capabilities that we may want to build in our framework:</p>
      <ul class="ak-ul">
         <li>
            <p>Mechanism to hold the previously executing handlers so that we can seek permission from them if the same handler is called again as a result of DML in same transaction. We may have to maintain the stack of handlers in the framework.</p>
         </li>
         <li>
            <p>Figure out the context in which current trigger is firing or executing, is it UI context or DML performed from some lightning component/VF Page/Another trigger. We must introduce some intent passing mechanism to be able to understand cause of the DML.</p>
         </li>
         <li>
            <p>Trigger blocking configuration, this is the way round we must configure the context, profile and user to whom we want to block the trigger. That means trigger framework should be able to identify the context in which trigger is being executed. As an example, batch, scheduled class, rest context etc.</p>
         </li>
         <li>
            <p>Additionally, at framework level we should be able to set flags to temporarily stop executing the triggers for an instance. As an example, Opportunity trigger performing DML on opportunity itself, so instead of detecting re-entrant simply turn off the triggers by leveraging frameworks capability. &nbsp;(This is very similar to Bypass API, but you don&rsquo;t have to remember the handler&rsquo;s name)</p>
         </li>
         <li>
            <p>Use of interface to force the developers to follow the development guidelines and use the template that compliant with framework.</p>
         </li>
      </ul>
      <h1>4. Trigger Components</h1>
      <p>Main components of the trigger framework are dispatcher, an interface that has all the event handler methods and handler class.</p>
      <p>The idea of using interface is to keep all the trigger handlers&rsquo; uniform and follow the same structure. Interface has methods for each trigger event, and handler must implement those methods. Let us name the interface as <strong>ITriggerHandler</strong>.</p>
      <pre><code data-language="java">public interface ITriggerHandler {    
    void beforeInsert(List&lt;SObject&gt; newItems);    
    void beforeUpdate(Map&lt;Id, SObject&gt; newItems, Map&lt;Id, SObject&gt; oldItems);    
    void beforeDelete(Map&lt;Id, SObject&gt; oldItems);    
    void afterInsert(Map&lt;Id, SObject&gt; newItems);    
    void afterUpdate(Map&lt;Id, SObject&gt; newItems, Map&lt;Id, SObject&gt; oldItems);    
    void afterDelete(Map&lt;Id, SObject&gt; oldItems);    
    void afterUndelete(Map&lt;Id, SObject&gt; oldItems);    
    boolean seekPermission(TriggerEventRouter.TriggerInfo triggerInfo);   
}</code></pre>
      <p>Interface has special method named seekPermission. If new handler is triggered due to a DML fired from previous handler then framework detects it and requests for permission to this handler for that to execute. Handler should not be called directly from seekPermission method and will always have Trigger context of the child hence this should be used only for decision making. DMLs are not allowed in seekPermission method because it&rsquo;s a part of framework, so we should use it carefully. We will talk more about TriggerInfo class in next sections.</p>
      <p>Dispatcher is a class which uses reflection to instantiate the handler class, but in our trigger framework we will call it as an event router, say <strong>TriggerEventRouter</strong>. Ideally just performing the routing i.e. calling the correct method based on the event hence the name. As name suggest router class will have route method which will be an entry point for our trigger framework. Route method will take the handler instance from the trigger and will call the appropriate method based on trigger event.</p>
      <p>Now we will see how we can create a handler class which implements the ITriggerHandler interface. Let&rsquo;s assume that, you want to create a trigger on Opportunity object, obviously we will name the handler as OpportunityTriggerHandler. But you can give any name for that matter.</p>
      <pre><code data-language="java">public class OpportunityTriggerHandler implements ITriggerHandler {
    
    public void beforeInsert(List&lt;SObject&gt; nOpportunityRecords) {}
    
    public void beforeUpdate(Map&lt;Id, SObject&gt; nOpportunityRecords, Map&lt;Id, SObject&gt; oOpportunityRecords) {}
    
    public void beforeDelete(Map&lt;Id, SObject&gt; oOpportunityRecords) {}
    
    public void afterInsert(Map&lt;Id, SObject&gt; nOpportunityRecords) {}
    
    public void afterUpdate(Map&lt;Id, SObject&gt; nOpportunityRecords, Map&lt;Id, SObject&gt; oOpportunityRecords) {}
    
    public void afterDelete(Map&lt;Id, SObject&gt; oOpportunityRecords) {}
    
    public void afterUndelete(Map&lt;Id, SObject&gt; oOpportunityRecords) {}   
    
    public boolean seekPermission(TriggerEventRouter.TriggerInfo tInfo) {
        if (!tInfo.possibleRecursion) return true;
        return false;
    }   
}</code></pre>
      <p>Interface and trigger handler class is now ready for use, now on wards we will see how to write routing logic and get the seekPermission method working.</p>
      <p>The main functionality that any trigger framework must have is detecting the loop.&nbsp; In order to detect loop, we will need following information.</p>
      <ul class="ak-ul">
         <li>
            <p>Trigger Information</p>
         </li>
         <li>
            <p>Trigger handlers History</p>
         </li>
      </ul>
      <p>Let us declare few variables that will be used across the TriggerEventRouter.</p>
      <pre><code data-language="java">private Enum TriggerEvents {beforeInsert, beforeUpdate, beforeDelete, afterInsert, afterUpdate, afterDelete, afterUndelete}
private static list&lt;TriggerInfo&gt; tInfoHistory = new list&lt;TriggerInfo&gt;();</code></pre>
      <p>Defining TriggerInfo class, this class holds the trigger handler instance, name, event name, a flag to indicate if the same trigger handler is fired again or not, no. of times the same handler was called in a transaction.</p>
      <pre><code data-language="java">public class TriggerInfo {
  //Name of the Sobject on which trigger is invoked
  public String sObjectName {get;set;}
  //Name of the handler called by Dispatcher
  public String handlerName {get;set;}
  //Name of the trigger event
  public String eventName {get;set;}
  //Possible Recursive Call of the same trigger in same transaction
  public boolean possibleRecursion {get;set;}
  //Occurances
  public Integer noOfOccurances {get;set;}
  //Trigger handler instance. This instance should not be used for any other purposes and do not call any method.
  public final ITriggerHandler handler {get;set;}
  
  public TriggerInfo(ITriggerHandler handler) {
    //make sure that handler instance is not null.
    this.handler = handler;
    this.possibleRecursion = false;
    this.noOfOccurances = 1;
    //Capture the object name
    if(Trigger.new != NULL) {
        this.sObjectName = Trigger.new[0].getSObjectType().getDescribe().getName();  
    } else {
        this.sObjectName = Trigger.old != NULL? Trigger.old[0].getSObjectType().getDescribe().getName() : 'Unknown';
    }
    //Capture the event name
    if(Trigger.IsBefore){
        if (Trigger.IsInsert)
            eventName = TriggerEventRouter.TriggerEvents.beforeInsert.name();                
        if (Trigger.IsUpdate)
            eventName = TriggerEventRouter.TriggerEvents.beforeUpdate.name();     
        if (Trigger.IsDelete)
            eventName = TriggerEventRouter.TriggerEvents.beforeDelete.name();
    } else {
        if (Trigger.IsInsert)
            eventName = TriggerEventRouter.TriggerEvents.afterInsert.name();
        if (Trigger.IsUpdate)
            eventName = TriggerEventRouter.TriggerEvents.afterUpdate.name();              
        if (trigger.IsDelete)
            eventName = TriggerEventRouter.TriggerEvents.afterDelete.name();
        if (trigger.isUndelete)
            eventName = TriggerEventRouter.TriggerEvents.afterUndelete.name();
    } 
    handlerName = handler != NULL ? String.valueOf(handler).split(':')[0] : '';
  }
  
  //Get name of the Trigger context Object Name + Event Name + Handler Name
  public String getName() {
    return this.sObjectName + this.eventName + this.handlerName;
  }
  
  //Copy will be passed to the handlers
  public TriggerInfo getCopy() {
    TriggerInfo tInfoCopy = new TriggerInfo(NULL);
    tInfoCopy.eventName = this.eventName;
    tInfoCopy.sObjectName = this.sObjectName;
    tInfoCopy.handlerName = this.handlerName;
    tInfoCopy.possibleRecursion = this.possibleRecursion;
    tInfoCopy.noOfOccurances = this.noOfOccurances;
    return tInfoCopy;
  }
}</code></pre>
      <p><strong>getName </strong>method of the class gives the name of the handler as a combination of Object Name + Event Name + Handler Name to make it unique. This way we can make the loop detection at event level.</p>
      <p><strong>getCopy </strong>method returns the copy of the TriggerInfo instance to be used in seekPermission method. The method does return the handler in order to avoid methods being called from outside of the framework.</p>
      <p>Now we will create a logic to detect the loop, define method named <strong>isTriggerInfoExists.</strong> Method takes the instance of the TriggerInfo class and checks it against the history sets the number of occurrences.</p>
      <pre><code data-language="java">@testVisible
private static boolean isTriggerInfoExists(TriggerInfo currentTriggerInfo) {
    boolean possibleRecursion = false;
    Integer count = 0;
    for(TriggerInfo tf : tInfoHistory) {
        if(tf.getName() == currentTriggerInfo.getName()) {
            possibleRecursion = true;
            count++;
        }
    }
    currentTriggerInfo.noOfOccurances = count;
    return possibleRecursion;
}</code></pre>
      <p>Route method look like</p>
      <pre><code data-language="java">public static void route(ITriggerHandler handler){
    TriggerInfo tInfo = new TriggerInfo(handler);
    if(isTriggerInfoExists(tInfo)) {
       tInfo.possibleRecursion = true;
       tInfoHistory.add(tInfo); //Add current trigger info to history
     } else {
        tInfo.possibleRecursion = false;
        tInfoHistory.add(tInfo); //Add current trigger info to history
     }
}</code></pre>
      <p>You must be remembering we have used the possibleRecursion flag in seekPermission method. If the flag is FALSE, then we allow the handler to run, otherwise return from the route method. Its time to build the logic to maintain the stack of handlers and to seek permission from running instance of the handler class.</p>
      <p>Consider the following situation where opportunity is being created in afterInsert event of the Opportunity trigger. This is going to create loop and its going to fail, maybe you will get Maximum Trigger Depth Exceeded exception. We have now identified recursion&nbsp;using trigger info history and we can leverage the seekPermission method to stop the recursion.</p>
      <div data-node-type="mediaSingle" data-layout="center" data-width="33">
         <div data-id="27ef420f-08ea-4bd6-be3f-5bf2b3ccd4b0" data-node-type="media" data-type="file" data-collection="contentId-1379336449" data-width="214" data-height="124" title="Attachment" data-file-name="image-20201007-235549.png" data-file-size="15058" data-file-mime-type="image/png" data-context-id="1379336449"></div>
      </div>
      <p>First time when afterInsert event is fired then handler stack will have the <em>OpportunityafterInsertOpportunityTriggerHandler</em>, during the execution of the afterInsert event, new DML statement is executed and it will fire the trigger again, Our stack is not empty, it will have the afterInsert event handler, so <em>OpportunitybeforeInsertOpportunityTriggerHandler </em>has to seek permission from the afterInsert handler in the stack. &nbsp;Here you will observe that beforeInsert handler is already present in the history hence the possibleRecursion flag will be TRUE, hence seekPermission will not allow the trigger to fire. Similarly, for afterInsert it must take permission from the previously running instance on afterInsert handler in the stack.</p>
      <p>What if you want to allow the beforeInsert trigger for every DML? To allow the beforeInsert trigger to run we must check the TriggerInfo that is available in seekPermission method, you can check the event name and make the decision if you want to allow trigger to run or not. &nbsp;This means seekPermission is centralized place to make the decision about which triggers will run in which scenario, you can also take the help of Static variables locally declared in your handler class to make the decisions. This can be done case by case basis.</p>
      <p>Now we have understood the theory behind the handler stack, lets implement some code.</p>
      <pre><code data-language="java">//Maintain the stack of Running Trigger Handlers
private static TriggerHandlerStack handlersStack = new TriggerHandlerStack();</code></pre>
      <p>Define a class TriggerHandlerStack as an inner class of TriggerEventRouter. The class will be a basic implementation of a stack. Stack items will be a list of TriggerInfo instances. It will have push, pop, peek methods to perform operations.</p>
      <pre><code data-language="java">/*Class represents the stack of handlers*/
public class TriggerHandlerStack {
    //List of items in stack
    private List&lt;TriggerInfo&gt; items {get; set;}
    
    //Constructor  
    public TriggerHandlerStack() {
        this.items = new List&lt;TriggerInfo&gt;();
    } 
    
    //Function to get the size of the stack
    public Integer size() {
        return this.items.size();
    }
    
    //Function to check if stack is empty
    public Boolean isEmpty() {
        return size() == 0;
    }    
    
    //Function to push an element to the stack
    public void push(TriggerInfo itemToPush) {
        this.items.add(itemToPush);
    }
    
    //Function to pop an element from the stack
    public TriggerInfo pop() {
        if (isEmpty()) {
            throw new StackUnderflowException();
        }        
        return this.items.remove(size() - 1);
    }
    
    //Function to check the top element of the stack
    public TriggerInfo peek() {
        if (isEmpty()) {
            throw new StackUnderflowException();
        }     
        return this.items.get(size() - 1);
    }    
}

/*Custom Exception when handler stack has no items, but framework is trying to pop the item.*/
public class StackUnderflowException extends Exception {}  </code></pre>
      <p>Route method will look like this.</p>
      <pre><code data-language="java">public static void route(ITriggerHandler handler){
    TriggerInfo tInfo = new TriggerInfo(handler);
    if(isTriggerInfoExists(tInfo)) {
       tInfo.possibleRecursion = true;
       tInfoHistory.add(tInfo); //Add current trigger info to history
     } else {
        tInfo.possibleRecursion = false;
        tInfoHistory.add(tInfo); //Add current trigger info to history
     }

     TriggerInfo runningHandlerTriggerInfo;
     //Check if this invocation was caused by some handler already executing then we ask for his permission
     if (!handlersStack.isEmpty()){
          runningHandlerTriggerInfo = handlersStack.peek();
          System.debug('--Seek Permission From--' + runningHandlerTriggerInfo.getName());
          if(runningHandlerTriggerInfo != null &amp;&amp; !runningHandlerTriggerInfo.handler.seekPermission(tInfo.getCopy())) {
              System.debug('--Permission Denide--');
              return;
          }
    }
}</code></pre>
      <p>Let's quickly add the actual routing logic in route method. You can use switch case as well, for simplicity I have used if-else ladder. Its important to pop the handler from the stack once the execution is completed.</p>
      <pre><code data-language="java">public static void route(ITriggerHandler handler){

    TriggerInfo tInfo = new TriggerInfo(handler);
    if(isTriggerInfoExists(tInfo)) {
       tInfo.possibleRecursion = true;
       tInfoHistory.add(tInfo); //Add current trigger info to history
    } else {
        tInfo.possibleRecursion = false;
        tInfoHistory.add(tInfo); //Add current trigger info to history
    }

    TriggerInfo runningHandlerTriggerInfo;
    //Check if this invocation was caused by some handler already executing then we ask for his permission
    if (!handlersStack.isEmpty()){
        runningHandlerTriggerInfo = handlersStack.peek();
        System.debug('--Seek Permission From--' + runningHandlerTriggerInfo.getName());
        if(runningHandlerTriggerInfo != null &amp;&amp; !runningHandlerTriggerInfo.handler.seekPermission(tInfo.getCopy())) {
            System.debug('--Permission Denide--');
            return;
        }
    }

    try {
        //Push the current handler in the stack.
        handlersStack.push(tInfo);
        
        if(Trigger.IsBefore){
            if (Trigger.IsInsert)
                handler.beforeInsert(trigger.new);            
            if (Trigger.IsUpdate)
                handler.beforeUpdate(trigger.newMap, trigger.oldMap);            
            if (Trigger.IsDelete)
                handler.beforeDelete(trigger.oldMap);
        } else {
            if (Trigger.IsInsert)
                handler.afterInsert(Trigger.newMap);           
            if (Trigger.IsUpdate)
                handler.afterUpdate(trigger.newMap, trigger.oldMap);           
            if (trigger.IsDelete)
                handler.afterDelete(trigger.oldMap);       
            if (trigger.isUndelete)
                handler.afterUndelete(trigger.oldMap);
        } 
    } catch(Exception ex) {
        //Handle Exceptions
    } finally {
        handlersStack.pop(); //Do not forget to pop the handler from stack.
    }
}</code></pre>
      <p>Great! Our basic framework is ready for use. TriggerEventRouter will look like this.</p>
      <pre><code data-language="java">public without sharing class TriggerEventRouter {
	
    //Enumeration for trigger event. (You can use TriggerOperation enum as well.)
    private Enum TriggerEvents {beforeInsert, beforeUpdate, beforeDelete, afterInsert, afterUpdate, afterDelete, afterUndelete}
    //Maintain the stack of Running Trigger Handlers
    private static TriggerHandlerStack handlersStack = new TriggerHandlerStack();
    //Maintain the list of all the trigger contexts invoked in transaction
    private static list&lt;TriggerInfo&gt; tInfoHistory = new list&lt;TriggerInfo&gt;();

    /*
    This method takes as a parameter the Trigger handler class that should implement the ITriggerHandler interface
    The only method that requires to be invoked from the triggers is route.
    TriggerEventRouter.route(new OpportunityTriggerHandler());
    */
    public static void route(ITriggerHandler handler){
        TriggerInfo tInfo = new TriggerInfo(handler);
        //Capture the history of the trigger handlers to detect the possible re entry of the same trigger.
        if(isTriggerInfoExists(tInfo)) {
            tInfo.possibleRecursion = true;
            tInfoHistory.add(tInfo); //Add current trigger info to history
        } else {
            tInfo.possibleRecursion = false;
            tInfoHistory.add(tInfo); //Add current trigger info to history
        }
        
        TriggerInfo runningHandlerTriggerInfo;
        //Check if this invocation was caused by some handler already executing then we ask for his permission
        if(!handlersStack.isEmpty()){
            runningHandlerTriggerInfo = handlersStack.peek();
            System.debug('--Seek Permission From--' + runningHandlerTriggerInfo.getName());
            if(runningHandlerTriggerInfo != null &amp;&amp; !runningHandlerTriggerInfo.handler.seekPermission(tInfo.getCopy())) {
                System.debug('--Permission Denide--');
                return;
            }
        }
        
        try {
            //Push the current handler in the stack.
            handlersStack.push(tInfo);
            if(Trigger.IsBefore){
                if (Trigger.IsInsert)
                    handler.beforeInsert(trigger.new);
                if (Trigger.IsUpdate)
                    handler.beforeUpdate(trigger.newMap, trigger.oldMap);
                if (Trigger.IsDelete)
                    handler.beforeDelete(trigger.oldMap);
            } else {
                if (Trigger.IsInsert)
                    handler.afterInsert(Trigger.newMap);
                if (Trigger.IsUpdate)
                    handler.afterUpdate(trigger.newMap, trigger.oldMap);
                if (trigger.IsDelete)
                    handler.afterDelete(trigger.oldMap);
                if (trigger.isUndelete)
                    handler.afterUndelete(trigger.oldMap);
            } 
        } catch(Exception ex) {
            System.debug('--Trigger Exception-' + ex.getMessage());
        } finally {
            handlersStack.pop();
        }
    }
    
    //This method will check if the current trigger has already executed in transaction or not and increase the count of the execution.
    @testVisible
    private static boolean isTriggerInfoExists(TriggerInfo currentTriggerInfo) {
        boolean possibleRecursion = false;
        Integer count = 0;
        for(TriggerInfo tf : tInfoHistory) {
            if(tf.getName() == currentTriggerInfo.getName()) {
                possibleRecursion = true;
                count++;
            }
        }
        currentTriggerInfo.noOfOccurances = count;
        return possibleRecursion;
    }
    
    public class TriggerInfo {
      //Name of the Sobject on which trigger is invoked
      public String sObjectName {get;set;}
      //Name of the handler called by Dispatcher
      public String handlerName {get;set;}
      //Name of the trigger event
      public String eventName {get;set;}
      //Possible Recursive Call of the same trigger in same transaction
      public boolean possibleRecursion {get;set;}
      //Occurances
      public Integer noOfOccurances {get;set;}
      //Trigger handler instance. This instance should not be used for any other purposes and do not call any method.
      public final ITriggerHandler handler {get;set;}
      
      public TriggerInfo(ITriggerHandler handler) {
          //make sure that handler instance is not null.
          this.handler = handler;
          this.possibleRecursion = false;
          this.noOfOccurances = 1;
          //Capture the object name
          if(Trigger.new != NULL) {
              this.sObjectName = Trigger.new[0].getSObjectType().getDescribe().getName();  
          } else {
              this.sObjectName = Trigger.old != NULL? Trigger.old[0].getSObjectType().getDescribe().getName() : 'Unknown';
          }
          //Capture the event name
          if(Trigger.IsBefore){
              if (Trigger.IsInsert)
                  eventName = TriggerEventRouter.TriggerEvents.beforeInsert.name();                
              if (Trigger.IsUpdate)
                  eventName = TriggerEventRouter.TriggerEvents.beforeUpdate.name();     
              if (Trigger.IsDelete)
                  eventName = TriggerEventRouter.TriggerEvents.beforeDelete.name();
          } else {
              if (Trigger.IsInsert)
                  eventName = TriggerEventRouter.TriggerEvents.afterInsert.name();
              if (Trigger.IsUpdate)
                  eventName = TriggerEventRouter.TriggerEvents.afterUpdate.name();              
              if (trigger.IsDelete)
                  eventName = TriggerEventRouter.TriggerEvents.afterDelete.name();
              if (trigger.isUndelete)
                  eventName = TriggerEventRouter.TriggerEvents.afterUndelete.name();
          } 
          handlerName = handler != NULL ? String.valueOf(handler).split(':')[0] : '';
        }
        
        //Get name of the Trigger context Object Name + Event Name + Handler Name
        public String getName() {
          return this.sObjectName + this.eventName + this.handlerName;
        }
        
        //Copy will be passed to the handlers
        public TriggerInfo getCopy() {
          TriggerInfo tInfoCopy = new TriggerInfo(NULL);
          tInfoCopy.eventName = this.eventName;
          tInfoCopy.sObjectName = this.sObjectName;
          tInfoCopy.handlerName = this.handlerName;
          tInfoCopy.possibleRecursion = this.possibleRecursion;
          tInfoCopy.noOfOccurances = this.noOfOccurances;
          return tInfoCopy;
        }
    }
    
    /*Class represents the stack of handlers*/
    public class TriggerHandlerStack {
        //List of items in stack
        private List&lt;TriggerInfo&gt; items {get; set;}
        
        //Constructor  
        public TriggerHandlerStack() {
            this.items = new List&lt;TriggerInfo&gt;();
        } 
        
        //Function to get the size of the stack
        public Integer size() {
            return this.items.size();
        }
        
        //Function to check if stack is empty
        public Boolean isEmpty() {
            return size() == 0;
        }    
        
        //Function to push an element to the stack
        public void push(TriggerInfo itemToPush) {
            this.items.add(itemToPush);
        }
        
        //Function to pop an element from the stack
        public TriggerInfo pop() {
            if (isEmpty()) {
                throw new StackUnderflowException();
            }        
            return this.items.remove(size() - 1);
        }
        
        //Function to check the top element of the stack
        public TriggerInfo peek() {
            if (isEmpty()) {
                throw new StackUnderflowException();
            }     
            return this.items.get(size() - 1);
        }    
    }
	
    /*Custom Exception when handler stack has no items, but framework is trying to pop the item.*/
	public class StackUnderflowException extends Exception {}  
}</code></pre>
      <p><strong>Calling trigger event router from the Opportunity Trigger.</strong></p>
      <pre><code>trigger OpportunityTrigger on Opportunity (before insert, before update, after insert, after update) {
    TriggerEventRouter.route(new OpportunityTriggerHandler());
}</code></pre>
      <h1>5. Adding capabilities to the framework</h1>
      <h2>Centralised Exception Handling</h2>
      <p>We already have added the try catch block around our routing logic, so that we can capture the exception at framework level only. Make sure that try catch is not used anywhere else in the helper and handler classes. You can catch the specific type of errors like SOQLException, DMLException and NullPointerException and display meaningful messages to the user instead of displaying technical details on the UI.</p>
      <p>If you want more advanced debugging then you can always leverage platform events to log the errors to custom object named Error_Log__c. You can create a platform event and configure it to publish immediately. Publish the platform event from finally block.</p>
      <pre><code data-language="java">try {
//Routing Logic
} catch(DMLException ex) {
    handleDMLException(ex);
} catch(NullPointerException ex) {
    //Show meaningful message to the user instead of showing the entire stackstrace
    addError('Technical error has occured. Please contact administrator.'); 
} catch(Exception ex) {
    //You can store the error message in custom label
    addError('Technical error has occured. Please contact administrator.');
} finally {
    handlersStack.pop();
}

//This method will parse the DML error message into meaningful error messages to be displayed on UI
@testVisible
private static void handleDMLException(Exception ex) {
    list&lt;String&gt; messages = new list&lt;String&gt;();
    for (Integer i = 0; i &lt; ex.getNumDml(); i++) {
        if(!messages.contains(ex.getDmlMessage(i)))
        	messages.add(ex.getDmlMessage(i));
    } 
    addError(String.join(messages, ',')); 
}

//This method will add the errors to the records so that user friendly messages can be displayed on the UI.
@testVisible
private static void addError(String message) {
    if(Trigger.isDelete || Trigger.isUndelete) { //In case of a delete trigger only old is available
        for(sObject record : Trigger.old) {
            record.addError(message);
        }
    } else {
        for(sObject record : Trigger.new) { //In case of non delete triggers new is available.
        	record.addError(message);
        }
    } 
}</code></pre>
      <h2>Bypassing the triggers</h2>
      <p>TriggerEventRouter is kind of a singleton class, hence we can introduce a public static boolean variable which can be used to stop the trigger execution as and when required. This feature can be useful while creating test data where you don&rsquo;t want triggers to run.</p>
      <pre><code data-language="java">//Should be set to TRUE at the start and should be reset to FALSE at the end of data setup/DML
public static Boolean stopTriggerExecution = false;</code></pre>
      <p>How to use it?</p>
      <pre><code data-language="java">//Route method look like this.
public static void route(ITriggerHandler handler){
    TriggerInfo tInfo = new TriggerInfo(handler);
    if(stopTriggerExecution) return;   
    //Routing logic here.
}

TriggerEventRouter.stopTriggerExecution = true;
Opportunity opportunityRecord = new Opportunity(Name = 'Opportunity-0', StageName = 'Qualification', CloseDate = Date.today() + 1, Amount = 1050000);
insert opportunityRecord;
TriggerEventRouter.stopTriggerExecution = false;</code></pre>
      <p>You should take extra care while using this flag, it has to be set to false after DML. If you do not set the flag to true then no triggers will run for all the consecutive DML statements.</p>
      <h2>Turn ON/OFF triggers from configuration</h2>
      <p>General ask from admin / data load teams is to be able to turn on/off the triggers as and when required. Some times it can go to granular level of Profile or user. You can make use of hierarchy custom settings.</p>
      <p>Create a custom setting named <span class="code" spellcheck="false">Trigger_Configuration__c</span>. Add org level and user level records as per your requirement. Create a Checkbox field for Opportunity object.</p>
      <p><strong>Label: </strong>Mute Opportunity Trigger <strong>API Name: </strong>Opportunity_MT__c <strong>Default: </strong>FALSE (Allow triggers to run)</p>
      <div data-node-type="mediaSingle" data-layout="center" data-width="">
         <div data-id="f3a88206-9283-41d7-8cbf-8ad87cb04b7b" data-node-type="media" data-type="file" data-collection="contentId-1379336449" data-width="995" data-height="336" title="Attachment" data-file-name="image-20201008-043319.png" data-file-size="70223" data-file-mime-type="image/png" data-context-id="1379336449"></div>
      </div>
      <pre><code data-language="java">//Method to decide if trigger should execute for the user or profile.
@testVisible
private static boolean executeTrigger(String sObjectName) {
    Boolean allowTriggerToRun = true;
    sObjectName = sObjectName.replace('__c', '');
    Trigger_Configuration__c configLEX = Trigger_Configuration__c.getInstance();
    try {
        //Get the Trigger ON/OFF checkbox value for the object 
        if(Boolean.valueOf(configLEX.get(sObjectName + '_MT__c'))) {
            allowTriggerToRun = false;
        }
    } catch(Exception ex) {
        allowTriggerToRun = true; //If no configuration found then allow trigger to run.
    }
    return allowTriggerToRun;
}

Just add the check inside route method around the routing logic.
if(executeTrigger(tInfo.sObjectName)) {
  //Routing logic goes here.
} else {
  System.debug('--Trigger Execution Blocked [User: ' + UserInfo.getName() + ', ProfileId: ' + UserInfo.getProfileId() + ', Id: ' + UserInfo.getUserId() + ']');
}</code></pre>
      <p>For more granular control you can additionally build a logic to get the context (batch, future etc.) in which trigger running, like updating opportunity in batch process where you do not want to run the triggers.</p>
      <p>In this case you may not be able to use the custom settings, because you want more parameters per user per profile, go for custom metadata or object to store the configuration. You can add getExecutionContext method to identify the context in which trigger is executing.</p>
      <pre><code data-language="java">//This&nbsp;method&nbsp;will&nbsp;give&nbsp;the&nbsp;current&nbsp;execution&nbsp;context&nbsp;where&nbsp;the&nbsp;trigger&nbsp;is&nbsp;executing.
@testVisible
private&nbsp;static&nbsp;String&nbsp;getExecutionContext()&nbsp;{
    if(System.isBatch())&nbsp;{
        return&nbsp;'Batch';
    }
    if(System.isScheduled())&nbsp;{
        return&nbsp;'Scheduled Job';
    }
    if(System.isFuture())&nbsp;{
        return&nbsp;'Future';
    }
    if(System.isQueueable())&nbsp;{
        return&nbsp;'Queueable';
    }
    if(RestContext.request&nbsp;!=&nbsp;null)&nbsp;{
        return&nbsp;'Rest';
    }
    return&nbsp;NULL;
}&nbsp;&nbsp;&nbsp;</code></pre>
      <h2>Provision for getting logged in user details</h2>
      <p>Most of the times developers need current/logged in user details or profile name for some validation checks or any other business specific logic. If you have bigger team chances are high that most of them will have their own queries to get the user details. To avoid these kind of situations (Reduce the SOQL count) we can provide these details through framework, they can simply call the method TriggerEventRouter.getUserDetails.</p>
      <p>Create a variable to hold user details locally in the framework. Make it private so that it can be accessed via method only. Initialise the variable in static block and expose it via method.</p>
      <pre><code data-language="java">private static User loggedInUser;

static {
    if(loggedInUser == NULL) {
      loggedInUser = [SELECT Id, Name, Email, Profile.Name FROM User WHERE Id: UserInfo.getUserId()];
    }
}

public static User getUserDetails() {
    return loggedInUser;
}</code></pre>
      <p>Lets wrap up by joining all the pieces together.</p>
      <pre><code data-language="java">public without sharing class TriggerEventRouter {
	
    //Enumeration for trigger event. (You can use TriggerOperation enum as well.)
    private Enum TriggerEvents {beforeInsert, beforeUpdate, beforeDelete, afterInsert, afterUpdate, afterDelete, afterUndelete}
    
    //Maintain the stack of Running Trigger Handlers
    private static TriggerHandlerStack handlersStack = new TriggerHandlerStack();
    
    //Maintain the list of all the trigger contexts invoked in transaction
    private static list&lt;TriggerInfo&gt; tInfoHistory = new list&lt;TriggerInfo&gt;();
    
    //Should be set to TRUE at the start and should be reset to FALSE at the end of data setup/DML
    public static Boolean stopTriggerExecution = false;
    
    //Logged in user details
    private static User loggedInUser;

    static {
        if(loggedInUser == NULL) {
          loggedInUser = [SELECT Id, Name, Email, Profile.Name FROM User WHERE Id=: UserInfo.getUserId()];
        }
    }

    //This method will retun the current user details.
    public static User getUserDetails() {
        return loggedInUser;
    }

    /*
    This method takes as a parameter the Trigger handler class that should implement the ITriggerHandler interface
    The only method that requires to be invoked from the triggers is route.
    TriggerEventRouter.route(new OpportunityTriggerHandler());
    */
    public static void route(ITriggerHandler handler){
        TriggerInfo tInfo = new TriggerInfo(handler);

        if(stopTriggerExecution) return;   

        //Capture the history of the trigger handlers to detect the possible re entry of the same trigger.
        if(isTriggerInfoExists(tInfo)) {
            tInfo.possibleRecursion = true;
            tInfoHistory.add(tInfo); //Add current trigger info to history
        } else {
            tInfo.possibleRecursion = false;
            tInfoHistory.add(tInfo); //Add current trigger info to history
        }
        
        TriggerInfo runningHandlerTriggerInfo;
        //Check if this invocation was caused by some handler already executing then we ask for his permission
        if(!handlersStack.isEmpty()){
            runningHandlerTriggerInfo = handlersStack.peek();
            System.debug('--Seek Permission From--' + runningHandlerTriggerInfo.getName());
            if(runningHandlerTriggerInfo != null &amp;&amp; !runningHandlerTriggerInfo.handler.seekPermission(tInfo.getCopy())) {
                System.debug('--Permission Denide--');
                return;
            }
        }
        
        try {
            //Push the current handler in the stack.
            handlersStack.push(tInfo);

            if(executeTrigger(tInfo.sObjectName)) {
                if(Trigger.IsBefore){
                    if (Trigger.IsInsert)
                        handler.beforeInsert(trigger.new);
                    if (Trigger.IsUpdate)
                        handler.beforeUpdate(trigger.newMap, trigger.oldMap);
                    if (Trigger.IsDelete)
                        handler.beforeDelete(trigger.oldMap);
                } else {
                    if (Trigger.IsInsert)
                        handler.afterInsert(Trigger.newMap);
                    if (Trigger.IsUpdate)
                        handler.afterUpdate(trigger.newMap, trigger.oldMap);
                    if (trigger.IsDelete)
                        handler.afterDelete(trigger.oldMap);
                    if (trigger.isUndelete)
                        handler.afterUndelete(trigger.oldMap);
                } 
            } else {
                System.debug('--Trigger Execution Blocked [User: ' + UserInfo.getName() + ', ProfileId: ' + UserInfo.getProfileId() + ', Id: ' + UserInfo.getUserId() + ']');
            }
        } catch(DMLException ex) {
            handleDMLException(ex);
        } catch(NullPointerException ex) {
            //Show meaningful message to the user instead of showing the entire stackstrace
            addError('Technical error has occurred. Please contact administrator.'); 
        } catch(Exception ex) {
            //You can store the error message in custom label
            addError('Technical error has occurred. Please contact administrator.');
        } finally {
            handlersStack.pop();
        }
    }

    //This method will parse the DML error message into meaningful error messages to be displayed on UI
    @testVisible
    private static void handleDMLException(Exception ex) {
        list&lt;String&gt; messages = new list&lt;String&gt;();
        for (Integer i = 0; i &lt; ex.getNumDml(); i++) {
            if(!messages.contains(ex.getDmlMessage(i)))
                messages.add(ex.getDmlMessage(i));
        } 
        addError(String.join(messages, ',')); 
    }

    //This method will add the errors to the records so that user friendly messages can be displayed on the UI.
    @testVisible
    private static void addError(String message) {
        if(Trigger.isDelete || Trigger.isUndelete) { //In case of a delete trigger only old is available
            for(sObject record : Trigger.old) {
                record.addError(message);
            }
        } else {
            for(sObject record : Trigger.new) { //In case of non delete triggers new is available.
                record.addError(message);
            }
        } 
    }
    
    //This method will check if the current trigger has already executed in transaction or not and increase the count of the execution.
    @testVisible
    private static boolean isTriggerInfoExists(TriggerInfo currentTriggerInfo) {
        boolean possibleRecursion = false;
        Integer count = 0;
        for(TriggerInfo tf : tInfoHistory) {
            if(tf.getName() == currentTriggerInfo.getName()) {
                possibleRecursion = true;
                count++;
            }
        }
        currentTriggerInfo.noOfOccurences = count;
        return possibleRecursion;
    }
    
    //Method to if the trigger is turned off from the configuration or not.
    @testVisible
    private static boolean executeTrigger(String sObjectName) {
        Boolean allowTriggerToRun = true;
        sObjectName = sObjectName.replace('__c', '');
        Trigger_Configuration__c config = Trigger_Configuration__c.getInstance();
        try {
            //Get the Trigger ON/OFF checkbox value for the object 
            if(Boolean.valueOf(config.get(sObjectName + '_MT__c'))) {
                allowTriggerToRun = false;
            }
        } catch(Exception ex) {
            allowTriggerToRun = true; //If no configuration found then allow trigger to run.
        }
        return allowTriggerToRun;
    }

    /*This class instance will store the Object Name, trigger event and handler name to identify the potential recursion in same transaction/trigger context.*/
    public class TriggerInfo {
        //Name of the Sobject on which trigger is invoked
        public String sObjectName {get;set;}
        //Name of the handler called by Dispatcher
        public String handlerName {get;set;}
        //Name of the trigger event
        public String eventName {get;set;}
        //Possible Recursive Call of the same trigger in same transaction
        public boolean possibleRecursion {get;set;}
        //Occurences
        public Integer noOfOccurences {get;set;}
        //Trigger handler instance. This instance should not be used for any other purposes and do not call any method.
        public final ITriggerHandler handler {get;set;}
		
        public TriggerInfo(ITriggerHandler handler) {
            //make sure that handler instance is not null.
            this.handler = handler;
            this.possibleRecursion = false;
            this.noOfOccurences = 1;
            //Capture the object name
            if(Trigger.new != NULL) {
                this.sObjectName = Trigger.new[0].getSObjectType().getDescribe().getName();  
            } else {
                this.sObjectName = Trigger.old != NULL? Trigger.old[0].getSObjectType().getDescribe().getName() : 'Unknown';
            }
            //Capture the event name
            if(Trigger.IsBefore){
                if (Trigger.IsInsert)
                    eventName = TriggerEventRouter.TriggerEvents.beforeInsert.name();                
                if (Trigger.IsUpdate)
                    eventName = TriggerEventRouter.TriggerEvents.beforeUpdate.name();     
                if (Trigger.IsDelete)
                    eventName = TriggerEventRouter.TriggerEvents.beforeDelete.name();
            } else {
                if (Trigger.IsInsert)
                    eventName = TriggerEventRouter.TriggerEvents.afterInsert.name();
                if (Trigger.IsUpdate)
                    eventName = TriggerEventRouter.TriggerEvents.afterUpdate.name();              
                if (trigger.IsDelete)
                    eventName = TriggerEventRouter.TriggerEvents.afterDelete.name();
                if (trigger.isUndelete)
                    eventName = TriggerEventRouter.TriggerEvents.afterUndelete.name();
            } 
            handlerName = handler != NULL ? String.valueOf(handler).split(':')[0] : '';
        }
        
        //Get name of the Trigger context Object Name + Event Name + Handler Name
        public String getName() {
            return this.sObjectName + this.eventName + this.handlerName;
        }
        
        //Copy will be passed to the handlers
        public TriggerInfo getCopy() {
            TriggerInfo tInfoCopy = new TriggerInfo(NULL);
            tInfoCopy.eventName = this.eventName;
            tInfoCopy.sObjectName = this.sObjectName;
            tInfoCopy.handlerName = this.handlerName;
            tInfoCopy.possibleRecursion = this.possibleRecursion;
            tInfoCopy.noOfOccurences = this.noOfOccurences;
            return tInfoCopy;
        }
    }
    
    /*Class represents the stack of handlers*/
    public class TriggerHandlerStack {
        //List of items in stack
        private List&lt;TriggerInfo&gt; items {get; set;}
        
        //Constructor  
        public TriggerHandlerStack() {
            this.items = new List&lt;TriggerInfo&gt;();
        } 
        
        //Function to get the size of the stack
        public Integer size() {
            return this.items.size();
        }
        
        //Function to check if stack is empty
        public Boolean isEmpty() {
            return size() == 0;
        }    
        
        //Function to push an element to the stack
        public void push(TriggerInfo itemToPush) {
            this.items.add(itemToPush);
        }
        
        //Function to pop an element from the stack
        public TriggerInfo pop() {
            if (isEmpty()) {
                throw new StackUnderflowException();
            }        
            return this.items.remove(size() - 1);
        }
        
        //Function to check the top element of the stack
        public TriggerInfo peek() {
            if (isEmpty()) {
                throw new StackUnderflowException();
            }     
            return this.items.get(size() - 1);
        }    
    }
	
    /*Custom Exception when handler stack has no items, but framework is trying to pop the item.*/
	public class StackUnderflowException extends Exception {}  
}</code></pre>
      <h1>Future enhancements</h1>
      <p>Right now there is no way we can directly figure out the exact cause of the DML, as an example if the record was created from the ui, batch or any other code for that matter. Android does have a mechanism to pass the intent from one activity to other. Similarly we should be able to add intent on a record which is being created via DML. Intent will give us an idea what operation should be performed, as an example intent can hold class name that can be dynamically instantiated.</p>
      <p></p>
      <p></p>
      <p></p>
   </body>
</html>